<html><head><title>The Squid Server and mod_perl (Practical mod_perl)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Stas Bekman and Eric Cholet" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0-596-00227-0" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Practical mod_perl" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">




<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch12_05.html"><img src="../images//txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="ch12_07.html"><img src="../images//txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>



<h2 class="sect1">12.6. The Squid Server and mod_perl</h2>

<p>To give you an<a name="pmodperl-CHP-12-ITERM-4968" /><a name="pmodperl-CHP-12-ITERM-4969" />
idea of what Squid is, we will reproduce the following bullets from
Squid's home page <a name="pmodperl-CHP-12-ITERM-4970" />(<a href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>):</p>

<p>Squid is...</p>

<ul><li>
<p>A full-featured web proxy cache</p>
</li><li>
<p>Designed to run on Unix systems</p>
</li><li>
<p>Free, open source software</p>
</li><li>
<p>The result of many contributions by unpaid volunteers</p>
</li><li>
<p>Funded by the National Science Foundation</p>
</li></ul>
<p>Squid supports...</p>

<ul><li>
<p>Proxying and caching of HTTP, FTP, and other URLs</p>
</li><li>
<p>Proxying for SSL</p>
</li><li>
<p>Cache hierarchies</p>
</li><li>
<p>ICP, HTCP, CARP, and Cache Digests</p>
</li><li>
<p>Transparent caching</p>
</li><li>
<p>WCCP (Squid v2.3)</p>
</li><li>
<p>Extensive access controls</p>
</li><li>
<p><em class="emphasis">httpd</em> server acceleration</p>
</li><li>
<p>SNMP</p>
</li><li>
<p>Caching of DNS lookups</p>
</li></ul>
<a name="pmodperl-CHP-12-SECT-6.1" /><div class="sect2">
<h3 class="sect2">12.6.1. Pros and Cons</h3>

<p>The<a name="pmodperl-CHP-12-ITERM-4971" /><a name="pmodperl-CHP-12-ITERM-4972" />
advantages of using Squid are:</p>

<ul><li>
<p>Caching of static objects. These are served much faster, assuming
that your cache size is big enough to keep the most frequently
requested objects in the cache.</p>
</li><li>
<p>Buffering of dynamic content. This takes the burden of returning the
content generated by mod_perl servers to slow clients, thus freeing
mod_perl servers from waiting for the slow clients to download the
data. Freed servers immediately switch to serve other requests; thus,
your number of required servers goes down dramatically.</p>
</li><li>
<p>Nonlinear URL space/server setup. You can use Squid to play some
tricks with the URL space and/or domain-based virtual server support.</p>
</li></ul>
<p>The disadvantages are:</p>

<ul><li>
<p>Buffering limit. By default, Squid buffers in only 16 KB chunks, so
it will not allow mod_perl to complete immediately if the output is
larger. (<tt class="literal">READ_AHEAD_GAP</tt>, which is 16 KB by
default, can be enlarged in <em class="emphasis">defines.h</em> if your OS
allows that.)</p>
</li><li>
<p>Speed. Squid is not very fast when compared with the plain file-based
web servers available today. Only if you are using a lot of dynamic
features, such as with mod_perl, is there a reason to use Squid, and
then only if the application and the server are designed with caching
in mind.</p>
</li><li>
<p>Memory usage. Squid uses quite a bit of memory. It can grow three
times bigger than the limit provided in the configuration file.</p>
</li><li>
<p>HTTP protocol level. Squid is pretty much an HTTP/1.0 server, which
seriously limits the deployment of HTTP/1.1 features, such as
<tt class="literal">KeepAlive</tt>s.</p>
</li><li>
<p>HTTP headers, dates, and freshness. The Squid server might give out
stale pages, confusing downstream/client caches. This might happen
when you update some documents on the site&#8212;Squid will continue
serve the old ones until you explicitly tell it which documents are
to be reloaded from disk.</p>
</li><li>
<p>Stability. Compared to plain web servers, Squid is not the most
stable.</p>
</li></ul>
<p>The pros and cons presented above indicate that you might want to use
Squid for its dynamic content-buffering features, but only if your
server serves mostly dynamic requests. So in this situation, when
performance is the goal, it is better to have a plain Apache server
serving static objects and Squid proxying only the mod_perl-enabled
server. This means that you will have a triple server setup, with
frontend Squid proxying the backend light Apache server and the
backend heavy mod_perl server.</p>

</div>
<a name="pmodperl-CHP-12-SECT-6.2" /><div class="sect2">
<h3 class="sect2">12.6.2. Light Apache, mod_perl, and Squid Setup Implementation Details</h3>

<p>You will find the<a name="pmodperl-CHP-12-ITERM-4973" /><a name="pmodperl-CHP-12-ITERM-4974" /><a name="pmodperl-CHP-12-ITERM-4975" /> installation details for the Squid
server on the Squid web site (<a href="http://www.squid-cache.org/">http://www.squid-cache.org/</a>). In our case it
was preinstalled with Mandrake Linux. Once you have Squid installed,
you just need to modify the default <em class="emphasis">squid.conf</em>
file (which on our system was located at
<em class="emphasis">/etc/squid/squid.conf</em>), as we will explain now,
and you'll be ready to run it.</p>

<p>Before working on Squid's configuration,
let's take a look at what we are already running and
what we want from Squid.</p>

<p>Previously we had the <em class="emphasis">httpd_docs</em> and
<em class="emphasis">httpd_perl</em> servers listening on ports 80 and
8000, respectively. Now we want Squid to listen on port 80 to forward
requests for static objects (plain HTML pages, images, and so on) to
the port to which the <em class="emphasis">httpd_docs</em> server listens,
and dynamic requests to
<em class="emphasis">httpd_perl</em>'s port. We also want
Squid to collect the generated responses and deliver them to the
client. As mentioned before, this is known as <em class="emphasis">httpd</em>
accelerator mode in proxy dialect.</p>

<p>We have to reconfigure the <em class="emphasis">httpd_docs</em> server to
listen to port 81 instead, since port 80 will be taken by Squid.
Remember that in our scenario both copies of Apache will reside on
the same machine as Squid. The server configuration is illustrated in
<a href="ch12_06.html#pmodperl-CHP-12-FIG-4">Figure 12-4</a>.</p>

<a name="pmodperl-CHP-12-FIG-4" /><div class="figure"><img src="figs/pmp_1204.gif" alt="Figure 12-4" width="384" /></div><h4 class="objtitle">Figure 12-4. A Squid proxy server, standalone Apache, and mod_perl-enabled Apache</h4>

<p>A proxy server makes all the magic behind it transparent to users.
Both Apache servers return the data to Squid (unless it was already
cached by Squid). The client never sees the actual ports and never
knows that there might be more than one server running. Do not
confuse this scenario with mod_rewrite, where a server redirects the
request somewhere according to the rewrite rules and forgets all
about it (i.e., works as a one-way dispatcher, responsible for
dispatching the jobs but not for collecting the results).</p>

<p>Squid can be used as a straightforward proxy server. ISPs and big
companies generally use it to cut down the incoming traffic by
caching the most popular requests. However, we want to run it in
<em class="emphasis">httpd</em> accelerator mode. Two configuration
directives, <tt class="literal">httpd_accel_host</tt> and
<tt class="literal">httpd_accel_port</tt>, enable this mode. We will see
more details shortly.</p>

<p>If you are currently using Squid in the regular proxy mode, you can
extend its functionality by running both modes concurrently. To
accomplish this, you can extend the existing Squid configuration with
<em class="emphasis">httpd</em> accelerator mode's
related directives or you can just create a new configuration from
scratch.</p>

<p>Let's go through the changes we should make to the
default configuration file. Since the file with default settings
(<em class="emphasis">/etc/squid/squid.conf</em><a name="pmodperl-CHP-12-ITERM-4976" />) is huge (about 60 KB) and we will not
alter 95% of its default settings, our suggestion is to write a new
configuration file that includes the modified directives.<a href="#FOOTNOTE-42">[42]</a></p>
<blockquote><a name="FOOTNOTE-42" /><p> [42]The configuration directives we use are correct for Squid Cache
Version 2.4STABLE1. It's possible that the
configuration directives might change in new versions of
Squid.</p> </blockquote>

<p>First we want to enable the redirect feature, so we can serve
requests using more than one server (in our case we have two: the
<em class="emphasis">httpd_docs</em> and <em class="emphasis">httpd_perl</em>
servers). So we specify <tt class="literal">httpd_accel_host</tt> as
<tt class="literal">virtual</tt>. (This assumes that your server has
multiple interfaces&#8212;Squid will bind to all of them.)</p>

<blockquote><pre class="code">httpd_accel_host virtual</pre></blockquote>

<p>Then we define the default port to which the requests will be sent,
unless they're redirected. We assume that most
requests will be for static documents (also, it's
easier to define redirect rules for the mod_perl server because of
the URI that starts with <em class="emphasis">/perl</em> or similar). We
have our <em class="emphasis">httpd_docs</em> listening on port 81:</p>

<blockquote><pre class="code">httpd_accel_port 81</pre></blockquote>

<p>And Squid listens to port 80:</p>

<blockquote><pre class="code">http_port 80</pre></blockquote>

<p>We do not use <tt class="literal">icp</tt> (<tt class="literal">icp</tt> is used
for cache sharing between neighboring machines, which is more
relevant in the proxy mode):</p>

<blockquote><pre class="code">icp_port 0</pre></blockquote>

<p><tt class="literal">hierarchy_stoplist</tt> defines a list of words that,
if found in a URL, cause the object to be handled directly by the
cache. Since we told Squid in the previous directive that we
aren't going to share the cache between neighboring
machines, this directive is irrelevant. In case you do use this
feature, make sure to set this directive to something like:</p>

<blockquote><pre class="code">hierarchy_stoplist /cgi-bin /perl</pre></blockquote>

<p>where <em class="emphasis">/cgi-bin</em> and <em class="emphasis">/perl</em>
are aliases for the locations that handle the dynamic requests.</p>

<p>Now we tell Squid not to cache dynamically generated pages:</p>

<blockquote><pre class="code">acl QUERY urlpath_regex /cgi-bin /perl
no_cache deny QUERY</pre></blockquote>

<p>Please note that the last two directives are controversial ones. If
you want your scripts to be more compliant with the HTTP standards,
according to the HTTP specification, the headers of your scripts
should carry the caching directives: <tt class="literal">Last-Modified</tt>
and <tt class="literal">Expires</tt>.</p>

<p>What are they for? If you set the headers correctly, there is no need
to tell the Squid accelerator <em class="emphasis">not</em> to try to
cache anything. Squid will not bother your mod_perl servers a second
time if a request is (a) cacheable and (b) still in the cache. Many
mod_perl applications will produce identical results on identical
requests if not much time has elapsed between the requests. So your
Squid proxy might have a hit ratio of 50%, which means that the
mod_perl servers will have only half as much work to do as they did
before you installed Squid (or mod_proxy).</p>

<p>But this is possible only if you set the headers correctly. Refer to
<a href="ch16_01.html">Chapter 16</a> to learn more about generating the
proper caching headers under mod_perl. In the case where only the
scripts under <em class="emphasis">/perl/caching-unfriendly</em> are not
caching-friendly, fix the above setting to be:</p>

<blockquote><pre class="code">acl QUERY urlpath_regex /cgi-bin /perl/caching-unfriendly
no_cache deny QUERY</pre></blockquote>

<p>If you are lazy, or just have too many things to deal with, you can
leave the above directives the way we described. Just keep in mind
that one day you will want to reread this section to squeeze even
more power from your servers without investing money in more memory
and better hardware.</p>

<p>While testing, you might want to enable the debugging options and
watch the log files in the directory
<em class="emphasis">/var/log/squid/</em>. But make sure to turn debugging
off in your production server. Below we show it commented out, which
makes it disabled, since it's disabled by default.
Debug option 28 enables the debugging of the access-control routes;
for other debug codes, see the documentation embedded in the default
configuration file that comes with Squid.</p>

<blockquote><pre class="code"># debug_options 28</pre></blockquote>

<p>We need to provide a way for Squid to dispatch requests to the
correct servers. Static object requests should be redirected to
<em class="emphasis">httpd_docs</em> unless they are already cached, while
requests for dynamic documents should go to the
<em class="emphasis">httpd_perl</em> server. The configuration:</p>

<blockquote><pre class="code">redirect_program /usr/lib/squid/redirect.pl
redirect_children 10
redirect_rewrites_host_header off</pre></blockquote>

<p>tells Squid to fire off 10 redirect daemons at the specified path of
the redirect daemon and (as suggested by Squid's
documentation) disables rewriting of any <tt class="literal">Host</tt>:
headers in redirected requests. The redirection daemon script is
shown later, in <a href="ch12_06.html#pmodperl-CHP-12-EX-1">Example 12-1</a>.</p>

<p>The maximum allowed request size is in kilobytes, which is mainly
useful during <tt class="literal">PUT</tt> and <tt class="literal">POST</tt>
requests. A user who attempts to send a request with a body larger
than this limit receives an "Invalid
Request" error message. If you set this parameter to
<tt class="literal">0</tt>, there will be no limit imposed. If you are
using <tt class="literal">POST</tt> to upload files, then set this to the
largest file's size plus a few extra kilobytes:</p>

<blockquote><pre class="code">request_body_max_size 1000 KB</pre></blockquote>

<p>Then we have access permissions, which we will not explain here. You
might want to read the documentation, so as to avoid any security
problems.</p>

<blockquote><pre class="code">acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255
acl myserver src 127.0.0.1/255.255.255.255
acl SSL_ports port 443 563
acl Safe_ports port 80 81 8080 81 443 563
acl CONNECT method CONNECT

http_access allow manager localhost
http_access allow manager myserver
http_access deny manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
# http_access allow all</pre></blockquote>

<p>Since Squid should be run as a non-<em class="emphasis">root</em> user,
you need these settings:</p>

<blockquote><pre class="code">cache_effective_user squid
cache_effective_group squid</pre></blockquote>

<p>if you are invoking Squid as <em class="emphasis">root</em>. The user
<em class="emphasis">squid</em> is usually created when the Squid server
is installed.</p>

<p>Now configure a memory size to be used for caching:</p>

<blockquote><pre class="code">cache_mem 20 MB</pre></blockquote>

<p>The Squid documentation warns that the actual size of Squid can grow
to be three times larger than the value you set.</p>

<p>You should also keep pools of allocated (but unused) memory available
for future use:</p>

<blockquote><pre class="code">memory_pools on</pre></blockquote>

<p>(if you have the memory available, of course&#8212;otherwise, turn it
off).</p>

<p>Now tighten the runtime permissions of the cache manager CGI script
(<em class="emphasis">cachemgr.cgi</em>, which comes bundled with Squid)
on your production server:</p>

<blockquote><pre class="code">cachemgr_passwd disable shutdown</pre></blockquote>

<p>If you are not using this script to manage the Squid server remotely,
you should disable it:</p>

<blockquote><pre class="code">cachemgr_passwd disable all</pre></blockquote>

<p>Put the redirection daemon script at the location you specified in
the <tt class="literal">redirect_program</tt> parameter in the
configuration file, and make it executable by the web server (see
<a href="ch12_06.html#pmodperl-CHP-12-EX-1">Example 12-1</a>).</p>

<a name="pmodperl-CHP-12-EX-1" /><div class="example">
<h4 class="objtitle">Example 12-1. redirect.pl</h4>
<blockquote><pre class="code">#!/usr/bin/perl -p
BEGIN { $|=1 }
s|www.example.com(?::81)?/perl/|www.example.com:8000/perl/|;</pre></blockquote>
</div>

<p>The regular expression in this script matches all the URIs that
include either the string
"www.example.com/perl/" or the
string "www.example.com:81/perl/"
and replaces either of these strings with
"www.example.com:8080/perl". No
matter whether the regular expression worked or not, the
<tt class="literal">$_</tt> variable is automatically printed, thanks to
the <em class="emphasis">-p</em> switch.</p>

<p>You must disable buffering in the redirector script.
<tt class="literal">$|=1;</tt> does the job. If you do not disable
buffering, <tt class="literal">STDOUT</tt> will be flushed only when its
buffer becomes full&#8212;and its default size is about 4,096
characters. So if you have an average URL of 70 characters, only
after about 59 (4,096/70) requests will the buffer be flushed and
will the requests finally reach the server. Your users will not wait
that long (unless you have hundreds of requests per second, in which
case the buffer will be flushed very frequently because
it'll get full very fast).</p>

<p>If you think that this is a very ineffective way to redirect, you
should consider the following explanation. The redirector runs as a
daemon; it fires up <em class="emphasis">N</em> redirect daemons, so there
is no problem with Perl interpreter loading. As with mod_perl, the
Perl interpreter is always present in memory and the code has already
been compiled, so the redirect is very fast (not much slower than if
the redirector was written in C). Squid keeps an open pipe to each
redirect daemon; thus, the system calls have no overhead.</p>

<p>Now it is time to restart the server:</p>

<blockquote><pre class="code">/etc/rc.d/init.d/squid restart</pre></blockquote>

<p>Now the Squid server setup is complete.</p>

<p>If on your setup you discover that port 81 is showing up in the URLs
of the static objects, the solution is to make both the Squid and
<em class="emphasis">httpd_docs</em> servers listen to the same port. This
can be accomplished by binding each one to a specific interface (so
they are listening to different sockets). Modify
<em class="emphasis">httpd_docs/conf/httpd.conf</em> as follows:</p>

<blockquote><pre class="code">Port 80
BindAddress 127.0.0.1
Listen 127.0.0.1:80</pre></blockquote>

<p>Now the <em class="emphasis">httpd_docs</em> server is listening only to
requests coming from the local server. You cannot access it directly
from the outside. Squid becomes a gateway that all the packets go
through on the way to the <em class="emphasis">httpd_docs</em> server.</p>

<p>Modify <em class="emphasis">squid.conf</em> as follows:</p>

<blockquote><pre class="code">http_port example.com:80
tcp_outgoing_address 127.0.0.1
httpd_accel_host 127.0.0.1
httpd_accel_port 80</pre></blockquote>

<p>It's important that <em class="emphasis">http_port</em>
specifies the external hostname, which doesn't map
to 127.0.0.1, because otherwise the <em class="emphasis">httpd_docs</em>
and Squid server cannot listen to the same port on the same address.</p>

<p>Now restart the Squid and <em class="emphasis">httpd_docs</em> servers (it
doesn't matter which one you start first), and
voil&#xE0;&#8212;the port number is gone.</p>

<p>You must also have the following entry in the file
<em class="emphasis">/etc/hosts</em> (chances are that
it's already there):</p>

<blockquote><pre class="code">127.0.0.1 localhost.localdomain localhost</pre></blockquote>

<p>Now if your scripts are generating HTML including fully qualified
self references, using 8000 or the other port, you should fix them to
generate links to point to port 80 (which means not using the port at
all in the URI). If you do not do this, users will bypass Squid and
will make direct requests to the mod_perl server's
port. As we will see later, just like with
<em class="emphasis">httpd_docs</em>, the <em class="emphasis">httpd_perl</em>
server can be configured to listen only to requests coming from
<em class="emphasis">localhost</em> (with Squid forwarding these requests
from the outside). Then users will not be able to bypass Squid.</p>

<p>The whole modified <em class="emphasis">squid.conf</em> file is shown in
<a name="pmodperl-CHP-12-ITERM-4977" /><a name="pmodperl-CHP-12-ITERM-4978" /><a name="pmodperl-CHP-12-ITERM-4979" /><a href="ch12_06.html#pmodperl-CHP-12-EX-2">Example 12-2</a>.</p>

<a name="pmodperl-CHP-12-EX-2" /><div class="example">
<h4 class="objtitle">Example 12-2. squid.conf</h4>
<blockquote><pre class="code">http_port example.com:80
tcp_outgoing_address 127.0.0.1
httpd_accel_host 127.0.0.1
httpd_accel_port 80

icp_port 0

acl QUERY urlpath_regex /cgi-bin /perl
no_cache deny QUERY

# debug_options 28

redirect_program /usr/lib/squid/redirect.pl
redirect_children 10
redirect_rewrites_host_header off

request_body_max_size 1000 KB

acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255
acl myserver src 127.0.0.1/255.255.255.255
acl SSL_ports port 443 563
acl Safe_ports port 80 81 8080 8081 443 563
acl CONNECT method CONNECT

http_access allow manager localhost
http_access allow manager myserver
http_access deny manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
# http_access allow all

cache_effective_user squid
cache_effective_group squid

cache_mem 20 MB

memory_pools on

cachemgr_passwd disable shutdown</pre></blockquote>
</div>

</div>
<a name="pmodperl-CHP-12-SECT-6.3" /><div class="sect2">
<h3 class="sect2">12.6.3. mod_perl and Squid Setup Implementation Details</h3>

<p>When one of <a name="pmodperl-CHP-12-ITERM-4980" /><a name="pmodperl-CHP-12-ITERM-4981" /><a name="pmodperl-CHP-12-ITERM-4982" />the authors was first told about Squid, he
thought: "Hey, now I can drop the
<em class="emphasis">httpd_docs</em> server and have just Squid and the
<em class="emphasis">httpd_perl</em> servers. Since all static objects
will be cached by Squid, there is no more need for the light
<em class="emphasis">httpd_docs</em> server."</p>

<p>But he was a wrong. Why? Because there is still the overhead of
loading the objects into the Squid cache the first time. If a site
has many static objects, unless a huge chunk of memory is devoted to
Squid, they won't all be cached, and the heavy
mod_perl server will still have the task of serving these objects.</p>

<p>How do we measure the overhead? The difference between the two
servers is in memory consumption; everything else (e.g., I/O) should
be equal. So you have to estimate the time needed to fetch each
static object for the first time at a peak period, and thus the
number of additional servers you need for serving the static objects.
This will allow you to calculate the additional memory requirements.
This amount can be significant in some installations.</p>

<p>So on our production servers we have decided to stick with the Squid,
<em class="emphasis">httpd_docs</em>, and <em class="emphasis">httpd_perl</em>
scenario, where we can optimize and fine-tune everything. But if in
your case there are almost no static objects to serve, the
<em class="emphasis">httpd_docs</em> server is definitely redundant; all
you need are the mod_perl server and Squid to buffer the output from
it.</p>

<p>If you want to proceed with this setup, install mod_perl-enabled
Apache and Squid. Then use a configuration similar to that in the
previous section, but without <em class="emphasis">httpd_docs</em> (see
<a href="ch12_06.html#pmodperl-CHP-12-FIG-5">Figure 12-5</a>). Also, you do not need the redirector
any more, and you should specify <tt class="literal">httpd_accel_host</tt>
as a name of the server instead of <tt class="literal">virtual</tt>.
Because you do not redirect, there is no need to bind two servers on
the same port, so you also don't need the
<tt class="literal">Bind</tt> or <tt class="literal">Listen</tt> directives in
<em class="emphasis">httpd.conf</em>.</p>

<a name="pmodperl-CHP-12-FIG-5" /><div class="figure"><img src="figs/pmp_1205.gif" alt="Figure 12-5" width="377" /></div><h4 class="objtitle">Figure 12-5. A Squid proxy server and mod_perl-enabled Apache</h4>

<p>The modified configuration for this simplified setup is given in
<a href="ch12_06.html#pmodperl-CHP-12-EX-3">Example 12-3</a> (see the explanations in the
previous<a name="pmodperl-CHP-12-ITERM-4983" /><a name="pmodperl-CHP-12-ITERM-4984" /><a name="pmodperl-CHP-12-ITERM-4985" /> section).</p>

<a name="pmodperl-CHP-12-EX-3" /><div class="example">
<h4 class="objtitle">Example 12-3. squid2.conf</h4>
<blockquote><pre class="code">httpd_accel_host example.com
httpd_accel_port 8000
http_port 80
icp_port 0

acl QUERY urlpath_regex /cgi-bin /perl
no_cache deny QUERY

# debug_options 28

# redirect_program /usr/lib/squid/redirect.pl
# redirect_children 10
# redirect_rewrites_host_header off

request_body_max_size 1000 KB

acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255
acl myserver src 127.0.0.1/255.255.255.255
acl SSL_ports port 443 563
acl Safe_ports port 80 81 8080 8081 443 563
acl CONNECT method CONNECT

http_access allow manager localhost
http_access allow manager myserver
http_access deny manager
http_access deny !Safe_ports
http_access deny CONNECT !SSL_ports
# http_access allow all

cache_effective_user squid
cache_effective_group squid

cache_mem 20 MB

memory_pools on

cachemgr_passwd disable shutdown</pre></blockquote>
</div>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="ch12_05.html"><img src="../images//txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img src="../images//txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="ch12_07.html"><img src="../images//txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">12.5. Adding a Proxy Server in httpd Accelerator Mode</td><td align="center" valign="top" width="228"><a href="index/index.html"><img src="../images//index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">12.7. Apache's mod_proxy Module</td></tr></table></div>
<hr width="684" align="left" />


<p><p><font size="-1"><a href="copyrght.html">Copyright &copy; 2003</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,92" href="../index.html"><area shape="rect" coords="89,1,204,113" href="../apache/index.html"><area shape="rect" coords="208,-1,296,136" href="../php/index.html"><area shape="rect" coords="301,-1,403,132" href="../modperl/index.html"><area shape="rect" coords="406,3,503,115" href="../mysql/index.html"><area shape="rect" coords="507,2,596,142" href="../lian/index.html"><area shape="rect" coords="600,1,690,127" href="../rlinux/index.html">
</map>

</body></html>
