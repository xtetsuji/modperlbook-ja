
<html><head><title>Hangman Application (Practical mod_perl)</title><link rel="stylesheet" type="text/css" href="../style/style1.css" />

<meta name="DC.Creator" content="Stas Bekman and Eric Cholet" /><meta name="DC.Format" content="text/xml" scheme="MIME" /><meta name="DC.Language" content="en-US" /><meta name="DC.Publisher" content="O'Reilly &amp; Associates, Inc." /><meta name="DC.Source" scheme="ISBN" content="0-596-00227-0" /><meta name="DC.Subject.Keyword" content="stuff" /><meta name="DC.Title" content="Practical mod_perl" /><meta name="DC.Type" content="Text.Monograph" />

</head><body bgcolor="#ffffff">




<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="appd_07.html"><img src="../images//txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228" /><td align="right" valign="top" width="228"><a href="appd_09.html"><img src="../images//txtnexta.gif" alt="Next" border="0" /></a></td></tr></table></div>

<!-- Tell TT2 not to parse this file
 [% TAGS <+ +> %]
-->


<h2 class="sect1">D.8. Hangman Application</h2>

<p>In this section we're going to
<a name="pmodperl-APP-D-ITERM-6504" /><a name="pmodperl-APP-D-ITERM-6505" />develop a web application based on
the classic hangman example from the O'Reilly book
<em class="emphasis">Writing Apache Modules with Perl and C</em>. Most of
the game logic is borrowed intact or with minor modifications.
However, when it comes to generating the HTML pages to return to the
client, the script calls on the Template Toolkit to perform the task.</p>

<a name="pmodperl-APP-D-SECT-8.1" /><div class="sect2">
<h3 class="sect2">D.8.1. Hangman CGI Script</h3>

<p>The first implementation shows <a name="pmodperl-APP-D-ITERM-6506" /><a name="pmodperl-APP-D-ITERM-6507" />a
simple all-in-one CGI script that gets the job done quickly and
easily. Following that, we'll look at how it can be
adapted into a Template Toolkit plug-in and subsequently deployed
under mod_perl.</p>

<p>Here's how the CGI script begins:</p>

<blockquote><pre class="code">#!/usr/bin/perl
#
# hangman1.pl
#
# This variation of the classic hangman game implements
# the game logic at the start of the CGI script to
# define a game state.  It then processes an all-in-one
# template to generate the HTML page.
#
# The 'state' variable maintains the state of the game.
# It contains the following:
#   word     =&gt; the unknown word
#   guessed  =&gt; list of the guessed letters
#   gameno   =&gt; the number of words the user has tried
#   won      =&gt; the number of times the user guessed correctly
#   total    =&gt; the total number of incorrect guesses
#   left     =&gt; the number of tries the user has left on this turn
#

use IO::File ( );
use CGI qw(:standard);
use Template;

use strict;
use constant URL   =&gt; '/cgi-bin/hangman1.pl';
use constant ICONS =&gt; '/icons/hangman';
use constant WORDS =&gt; '/usr/games/hangman-words';
use constant TRIES =&gt; 6;</pre></blockquote>

<p>Nothing too taxing here. We provide some sensible comments, load the
Perl modules we're going to use (including the
Template module, of course), and define some constants.</p>

<p>Next comes the core application logic:</p>

<blockquote><pre class="code"># retrieve the state
my $state = get_state( );

# reinitialize if we need to
$state = initialize($state) if !$state or param('restart');

# process the current guess, if any
my ($message, $status) = process_guess(param('guess') || '', $state );</pre></blockquote>

<p>We first call the <tt class="literal">get_state( )</tt>subroutine to
restore any current game state from the CGI parameters.
We'll see the definition of that subroutine a little
later. For now, all we need to know is that it might return
<tt class="literal">undef</tt>, indicating that there
isn't any current state. In this case, or if the
<tt class="literal">restart</tt> CGI parameter is set, we need to call
<tt class="literal">initialize( )</tt> to set the state to contain some
sensible starting values.</p>

<p>Then we call <tt class="literal">process_guess( )</tt> to process any
pending guess. We pass the value of the <tt class="literal">guess</tt> CGI
parameter or an empty string if not defined, and also a reference to
the <tt class="literal">$state</tt> hash array. The subroutine returns a
message and a status value that indicates the current state of play.</p>

<p>Now that we've got the application processing out of
the way, we can set about generating some output. To do this, we
create a <tt class="literal">Template</tt> object and call its
<tt class="literal">process( )</tt> method, specifying a template to
process and a hash reference containing template variables:</p>

<blockquote><pre class="code"># create a Template object
my $tt = Template-&gt;new( );

# define Template variables
my $vars = {
    url     =&gt; URL,
    icons   =&gt; ICONS,
    tries   =&gt; TRIES,
    title   =&gt; 'Template Toolkit Hangman #1',
    state   =&gt; $state,
    status  =&gt; $status,
    message =&gt; $message,
    wordmap =&gt; \&amp;wordmap,
};

# process the main template at the end of this file
$tt-&gt;process(*DATA, $vars) || die $tt-&gt;error( );</pre></blockquote>

<p>In this example we're going to define the main
template in the <tt class="literal">_ _DATA_ _</tt>section of the CGI
script itself. The Template <tt class="literal">process( )</tt> methods
allows a file handle such as <tt class="literal">*DATA</tt> to be specified
in place of a template name and will read the content and process it
accordingly. Doing this allows us to separate the game logic written
in Perl from the presentation template that generates the HTML page,
with the benefit of being able to keep everything self-contained in a
single file.</p>

<p>That's the main body of the Perl code. Before we
look at the template defined at the end of the file,
let's look at the subroutine definitions.</p>

<p>The <tt class="literal">get_state( )</tt>subroutine reads the values of a
number of CGI parameters and populates them into the
<tt class="literal">$state</tt> hash, which it then returns:</p>

<blockquote><pre class="code">sub get_state {
    return undef unless param( );
    my $state = {  };
    foreach (qw(word gameno left won total guessed)) {
        $state-&gt;{$_} = param($_);
    }
    return $state;
}</pre></blockquote>

<p>The <tt class="literal">initialize</tt>subroutine is called to start a new
game. It picks a new random word and updates the existing
<tt class="literal">$state</tt> hash or creates a new one:</p>

<blockquote><pre class="code">sub initialize {
    my $state = shift || { };

    # pick a word, any word
    my $list = IO::File-&gt;new(WORDS) 
        || die "Couldn't open ${\WORDS}: $!\n";
    my $word;
    rand($.) &lt; 1 &amp;&amp; ($word = $_) while &lt;$list&gt;;
    chomp $word;

    # setup state
    $state-&gt;{word}    = $word;
    $state-&gt;{left}    = TRIES;
    $state-&gt;{guessed} = '';
    $state-&gt;{gameno} += 1;
    $state-&gt;{won}    += 0;
    $state-&gt;{total}  += 0;
    return $state;
}</pre></blockquote>

<p>The <tt class="literal">process_guess( )</tt>subroutine contains the core
of the game logic. It processes the guess passed as the first
argument and updates the current state passed as the second. It
returns two values: a message for displaying to the user and a status
flag indicating the current state of play.</p>

<blockquote><pre class="code">sub process_guess {
    my($guess, $state) = @_;

    # lose immediately if user has no more guesses left
    return ('', 'lost') unless $state-&gt;{left} &gt; 0;

    my %guessed = map { $_ =&gt; 1 } $state-&gt;{guessed} =~ /(.)/g;
    my %letters = map { $_ =&gt; 1 } $state-&gt;{word} =~ /(.)/g;

    # return immediately if user has already guessed the word
    return ('', 'won') unless grep(!$guessed{$_}, keys %letters);

    # do nothing more if no guess
    return ('', 'continue') unless $guess;

    # This section processes individual letter guesses
    $guess = lc $guess;
    return ("Not a valid letter or word!", 'error') 
        unless $guess =~ /^[a-z]+$/;
    return ("You already guessed that letter!", 'error')
        if $guessed{$guess};

    # This section is called when the user guesses the whole word
    if (length($guess) &gt; 1 and $guess ne $state-&gt;{word}) {
        $state-&gt;{total} += $state-&gt;{left};
        return ( qq{Loser!  The word was "$state-&gt;{word}."}, 'lost')
    }

    # update the list of guesses
    foreach ($guess =~ /(.)/g) { $guessed{$_}++; }
    $state-&gt;{ guessed } = join '', sort keys %guessed;

    # correct guess -- word completely filled in
    unless (grep(!$guessed{$_}, keys %letters)) {
        $state-&gt;{won}++;
        return (qq{Bingola!  The word was "$state-&gt;{word}."}, 'won');
    }

    # incorrect guess
    if (!$letters{$guess}) {
        $state-&gt;{total}++;
        $state-&gt;{left}--;
        # user out of turns
        return (qq{The jig is up!  The word was "$state-&gt;{word}".}, 'lost')
            if $state-&gt;{left} &lt;= 0;
        # user still has some turns
        return ('Wrong guess!', 'continue');
    }

    # correct guess but word still incomplete
    return (qq{Good guess!}, 'continue');</pre></blockquote>

<p>}</p>

<p>In addition to these subroutines that are called from Perl, we also
define <tt class="literal">wordmap( )</tt> and bind it by reference to the
corresponding <tt class="literal">wordmap</tt> template argument. This
allows it to be called from within the template.</p>

<blockquote><pre class="code">sub wordmap {
    my($word, $guessed) = @_;
        my %guessed = map { $_ =&gt; 1 } $guessed =~ /(.)/g;
        join '', map { $guessed{$_} ? "$_ " : '_ ' } $word =~ /(.)/g;
}</pre></blockquote>

<p>The subroutine expects to be passed the current word and a string
containing the letters previously guessed. It returns a string
representing the word with only the guessed letters shown and the
others blanked out.</p>

<p>At the end of the script, we have the template that is processed to
generate the HTML output. Notice that it follows the <tt class="literal">_
_DATA_ _</tt> marker, which Perl will automatically bind to the
<tt class="literal">*DATA</tt> file handle that we passed as the first
argument to the <tt class="literal">process( )</tt> method.<a href="#FOOTNOTE-62">[62]</a></p>
<blockquote><a name="FOOTNOTE-62" /><p> [62]The drawback of using the <tt class="literal">_ _DATA_ _</tt> marker
is that you cannot run this script under
<tt class="literal">Apache::Registry</tt>, as we explained in <a href="ch06_01.html">Chapter 6</a>. However, the script can be easily converted
into a mod_perl handler, which has no problems with the <tt class="literal">_
_DATA_ _</tt> marker.</p> </blockquote>

<p>In the opening segment, we first define the content type and general
HTML headers. This is followed by a directive that defines a
particular <tt class="literal">format</tt> for displaying floating-point
numbers, done by means of a standard <tt class="literal">format</tt>
plug-in loaded via the <tt class="literal">USE</tt> directive. We then go
on to calculate the number of tries remaining and the current game
averages, storing them in a hash array named
<tt class="literal">average</tt>:</p>

<blockquote><pre class="code">_ _DATA_ _
Content-type: text/html

&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;[% title %]&lt;/title&gt;
&lt;/head&gt;

&lt;body onload="if (document.gf) document.gf.guess.focus( )"&gt;
[%
    # define a format for displaying averages
    USE format('%2.3f');

    # how many guesses left to go?
    tries_left = tries - state.left 

    # calculate current averages
    average = {
      current = state.total / state.gameno
      overall = state.gameno &gt; 1 
        ? ( state.total - (tries - state.left)) / (state.gameno - 1)
        : 0
    }
%]</pre></blockquote>

<p>This next section displays the game title and the appropriate image
for the number of tries left. It then generates a table to display
the current game averages. Note that the <tt class="literal">format</tt> is
now used to display the floating-point averages to a fixed precision.</p>

<blockquote><pre class="code">&lt;h1&gt;[% title %]&lt;/h1&gt;

&lt;img src="[% icons %]/h[% tries_left %].gif"
     align="left" alt="[[% tries_left %] tries left]" /&gt;

&lt;table width="100%"&gt;
&lt;tr&gt;
  &lt;td&gt;&lt;b&gt;Word #: [% state.gameno %]&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;Guessed: [% state.guessed %]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;&lt;b&gt;Won: [% state.won %]&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;Current average: [% format(average.current) %]&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;Overall average: [% format(average.overall) %]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;</pre></blockquote>

<p>This is where we display the current word with unguessed letters
blanked out. We're using the
<tt class="literal">wordmap</tt> variable, which results in a call back to
our <tt class="literal">wordmap</tt>subroutine. We pass the current word
and string of guessed letters as arguments:</p>

<blockquote><pre class="code">&lt;h2&gt;Word: [% wordmap(state.word, state.guessed) %]&lt;/h2&gt;</pre></blockquote>

<p>Is there a message to display? If so, this code makes it stand out as
a red level-2 heading; otherwise, it does nothing.</p>

<blockquote><pre class="code">[% IF message -%]
&lt;h2&gt;&lt;font color="red"&gt;[% message %]&lt;/font&gt;&lt;/h2&gt;
[% END %]</pre></blockquote>

<p>Now we can generate the input form:</p>

<blockquote><pre class="code">&lt;form method="post" action="[% url %]" name="gf"
      enctype="application/x-www-form-urlencoded"&gt;

[% FOREACH var = [ 'word' 'gameno' 'left'
                   'won' 'total' 'guessed' ]
-%]
&lt;input type="hidden" name="[% var %]" value="[% state.$var %]" /&gt;
[% END %]</pre></blockquote>

<p>We're taking the simple approach and using hidden
form variables to maintain the state of the game between requests.
The <tt class="literal">FOREACH</tt> loop shown above generates these
fields for each of <tt class="literal">state.word</tt>,
<tt class="literal">state.gameno</tt>, <tt class="literal">state.left</tt>,
<tt class="literal">state.won</tt>, <tt class="literal">state.total</tt>, and
<tt class="literal">state.guessed</tt>. Rather than spelling out each one,
it uses an interpolated variable, <tt class="literal">state.$var</tt>. The
leading <tt class="literal">$</tt> means that the value of the
<tt class="literal">var</tt> variable is used to specify the intended item
in <tt class="literal">state</tt>. In Perl, this would be just like writing
<tt class="literal">$state-&gt;{</tt> <tt class="literal">$var }</tt>.</p>

<blockquote><pre class="code">[% IF status =  = 'won' or status =  = 'lost' %]
   Do you want to play again?
   &lt;input type="submit" name="restart" value="Another game" /&gt;
[% ELSE %]
   Your guess: &lt;input type="text" name="guess" /&gt;
   &lt;input type="submit" name=".submit" value="Guess" /&gt;
[% END %]

&lt;/form&gt;</pre></blockquote>

<p>If the current game status is "won"
or "lost", the game is over and we
generate a button allowing the player to start a new game. Otherwise,
it's business as usual and we generate an input
field for the guess before closing up the form.</p>

<p>Finally, we have the page footer to add some trailing text and tidy
up everything nicely:</p>

<blockquote><pre class="code">&lt;br clear="all"&gt;
&lt;hr /&gt;

&lt;a href="[% url %]"&gt;Home&lt;/a&gt;

&lt;p&gt;
  &lt;cite style="fontsize: 10pt"&gt;graphics courtesy Andy Wardley&lt;/cite&gt;
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</pre></blockquote>

<p>And that's it! We now have a self-contained CGI
script that can be installed and run from a
<em class="emphasis">cgi-bin</em> directory with little or no <a name="pmodperl-APP-D-ITERM-6508" /><a name="pmodperl-APP-D-ITERM-6509" />configuration
required (see <a href="appd_08.html#pmodperl-APP-D-FIG-2">Figure D-2</a>).</p>

<a name="pmodperl-APP-D-FIG-2" /><div class="figure"><img src="figs/pmp_ad02.gif" alt="Figure D-2" width="481" /></div><h4 class="objtitle">Figure D-2. Self-contained CGI hangman</h4>

</div>
<a name="pmodperl-APP-D-SECT-8.2" /><div class="sect2">
<h3 class="sect2">D.8.2. Hangman with Modular Templates</h3>

<p>Perhaps the biggest<a name="pmodperl-APP-D-ITERM-6510" /><a name="pmodperl-APP-D-ITERM-6511" /> limitation of the previous example
is that the presentation template isn't at all
modular. In this example, we're going to split the
one large template into a number of smaller ones placed in separate
files. This makes the main template much simpler and easier to
follow. It also allows each of the individual template components to
be updated in isolation. If you want to change the display of the
game averages, for example, then you just need to edit the
<em class="emphasis">status</em> template and can leave everything else as
it is.</p>

<p>We're also going to use a standard
<em class="emphasis">html/page</em> template, provided as part of the
Template Toolkit, to generate the required container elements to make
a valid HTML page. The default location for these templates is
<em class="filename">/usr/local/tt2/templates</em>. You will also need to
define the directory in which you're going to put
the hangman templates. So, to the top of the previous script, we can
add the following constant definitions (tailor them to your local
values, of course):</p>

<blockquote><pre class="code">use constant TEMPLATES =&gt; '/home/stas/templates/hangman2';
use constant SHARED    =&gt; '/usr/local/tt2/templates';</pre></blockquote>

<p>Then, when we create the <tt class="literal">Template</tt> object, we
specify these directories as a list reference for the
<tt class="literal">INCLUDE_PATH</tt> option:</p>

<blockquote><pre class="code"># create a Template object
my $tt = Template-&gt;new({
    INCLUDE_PATH =&gt; [ TEMPLATES, SHARED ],
});</pre></blockquote>

<p>The rest of the script remains the same, with exception of the
template specified in the <tt class="literal">_ _DATA_ _</tt>section. This
can now be written as:</p>

<blockquote><pre class="code">_ _DATA_ _
Content-type: text/html

[% WRAPPER html/page
     html.head.title  = title
     html.body.onload = 'if (document.gf) document.gf.guess.focus( )'
%]

[% PROCESS header %]

[% IF status =  = 'won' or status =  = 'lost';
      PROCESS restart;
   ELSE;
      PROCESS guess;
   END
%]

[% PROCESS footer %]

[% END %]</pre></blockquote>

<p>We've moved the <em class="emphasis">header</em>, the
<em class="emphasis">footer</em>, and the two different variants of the
form out into separate templates. The entire page is enclosed within
a <tt class="literal">WRAPPER</tt> block, which generates the required
<tt class="literal">&lt;html&gt;</tt>, <tt class="literal">&lt;head&gt;</tt>, and
<tt class="literal">&lt;body&gt;</tt> tags to wrap around the page using
the standard <em class="filename">html/page</em> template.</p>

<p>The external <em class="emphasis">header</em> and
<em class="emphasis">footer</em> templates are shown in Examples D-6 and
D-7. According to the value of <tt class="literal">TEMPLATES</tt>set
above, these should be located in
<em class="filename">/home/stas/templates/hangman</em>.</p>

<a name="pmodperl-APP-D-EX-6" /><div class="example">
<h4 class="objtitle">Example D-6. hangman2/templates/header</h4>
<blockquote><pre class="code">&lt;h1&gt;[% title %]&lt;/h1&gt;

[% # how many guesses left to go?
   tries_left = tries - state.left
%]

[%# display the appropriate image -%]  
&lt;img src="[% icons %]/h[% tries_left %].gif"
     align="left" alt="[[% tries_left %] tries left]" /&gt;

[% # display the game averages
   PROCESS status 
%]</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-7" /><div class="example">
<h4 class="objtitle">Example D-7. hangman2/templates/footer</h4>
<blockquote><pre class="code">&lt;br clear="all"&gt;
&lt;hr /&gt;

&lt;a href="[% url %]"&gt;Home&lt;/a&gt;

&lt;p&gt;
  &lt;cite style="fontsize: 10pt"&gt;graphics courtesy Andy Wardley&lt;/cite&gt;
&lt;/p&gt;</pre></blockquote>
</div>

</div>
<a name="pmodperl-APP-D-SECT-8.3" /><div class="sect2">
<h3 class="sect2">D.8.3. Hangman Plug-in</h3>

<p>To take our example <a name="pmodperl-APP-D-ITERM-6512" /><a name="pmodperl-APP-D-ITERM-6513" />a <a name="pmodperl-APP-D-ITERM-6514" />stage further, we're
going to convert this simple application into a Template Toolkit
plug-in module. A plug-in is just like any other Perl module, except
that it lives in a special namespace
(<tt class="literal">Template::Plugin::*</tt>) and gets passed a reference
to a special variable, the context, when its <tt class="literal">new(
)</tt> constructor is called. Plug-ins can be loaded and used
via the <tt class="literal">USE</tt> directive. Here's
what the module looks like:<a href="#FOOTNOTE-63">[63]</a></p> <blockquote><a name="FOOTNOTE-63" /><p> [63]The code assumes that
Perl 5.6.0 or higher is used. If you are using an older version, use
the <tt class="literal">vars</tt> pragma instead of
<tt class="literal">our</tt>.</p> </blockquote>

<blockquote><pre class="code">#------------------------------------------------------------------
# Template::Plugin::Games::Hangman
#
# Implementation of the classic hangman game written as a 
# plug-in module for the Template Toolkit.
#
# Written by Andy Wardley.
#------------------------------------------------------------------

package Template::Plugin::Games::Hangman;

use strict;
use Template::Plugin;
use Template::Exception;
use IO::File ( );
use CGI;

use base qw( Template::Plugin );

our $URL    = '/cgi-bin/hangman';
our $ICONS  = '/icons/hangman';
our $WORDS  = '/usr/games/hangman-words';
our $TRIES  = 6;
our @STATE  = qw( word gameno left won total guessed );</pre></blockquote>

<p>The start of the module is very similar to the CGI script. In this
case we're defining everything to be in the
<tt class="literal">Template::Plugin::Games::Hangman</tt> namespace and
specifying that it is a subclass of the
<tt class="literal">Template::Plugin</tt> module.</p>

<blockquote><pre class="code">sub new {
    my($class, $context, $config) = @_;

    # create plugin object
    my $self = bless {
        cgi      =&gt; CGI-&gt;new( ),
        url      =&gt; $config-&gt;{ url    } || $URL,
        icons    =&gt; $config-&gt;{ icons  } || $ICONS,
        words    =&gt; $config-&gt;{ words  } || $WORDS,
        tries    =&gt; $config-&gt;{ tries  } || $TRIES,
        _context =&gt; $context,
    }, $class;

    # restore current game or start new game
    $self-&gt;restore( ) || $self-&gt;init( );

    return $self;
}</pre></blockquote>

<p>When the plug-in is loaded via a <tt class="literal">USE</tt> directive,
the <tt class="literal">new( )</tt> constructor method is called. The first
(zeroth) argument is the calling class name,
<tt class="literal">Template::Plugin::Games::Hangman-&gt;new($context,
$config)</tt>, passed as a reference to a context object through
which you can access the functionality of the Template Toolkit. The
second argument is a reference to a hash array of any configuration
items specified with the <tt class="literal">USE</tt> directive.</p>

<p>This method defines an object, <tt class="literal">$self</tt>, using values
defined in the <tt class="literal">$config</tt> hash or the defaults
specified in the approprate package variables. It then calls the
<tt class="literal">restore( )</tt> method and, if <tt class="literal">restore(
)</tt> doesn't return a true value, the
<tt class="literal">init( )</tt> method. Here are the definitions of those
methods:</p>

<blockquote><pre class="code">sub restore {
    my $self = shift;
    my $cgi  = $self-&gt;{ cgi };
    return undef if !$cgi-&gt;param( );
    $self-&gt;{ $_ } = $cgi-&gt;param($_) foreach @STATE;
    return undef if $cgi-&gt;param('restart');
    return $self;
}

sub init {
    my $self = shift;

    # pick a word, any word
    my $list = IO::File-&gt;new($WORDS)
        || die "failed to open '$WORDS' : $!\n";
    my $word;
    rand($.) &lt; 1 &amp;&amp; ($word = $_) while &lt;$list&gt;;
    chomp $word;

    $self-&gt;{ word    }  = $word;
    $self-&gt;{ left    }  = $self-&gt;{ tries };
    $self-&gt;{ guessed }  = '';
    $self-&gt;{ gameno  } += 1;
    $self-&gt;{ won     } += 0;
    $self-&gt;{ total   } += 0;
    return $self;
}</pre></blockquote>

<p>They are just like their counterparts in the earlier CGI script, with
a few minor exceptions. A CGI object is defined in
<tt class="literal">$self-&gt;{ cgi }</tt> rather than using imported
subroutines, and operations are performed on <tt class="literal">$self</tt>
rather than on a <tt class="literal">$state</tt> hash array passed as an
argument.</p>

<p>The <tt class="literal">guess( )</tt> method is also very similar to the
<tt class="literal">process_guess( )</tt>subroutine in the CGI script:</p>

<blockquote><pre class="code">sub guess {
    my $self  = shift;
    my $cgi   = $self-&gt;{ cgi };
    my $guess = $cgi-&gt;param('guess') || return;

    # lose immediately if user out of guesses
    return $self-&gt;state('lost') 
        unless $self-&gt;{ left } &gt; 0;

    my %guessed = map { $_ =&gt; 1 } $self-&gt;{ guessed } =~ /(.)/g;
    my %letters = map { $_ =&gt; 1 } $self-&gt;{ word    } =~ /(.)/g;

    # return immediately if user has already guessed the word
    return $self-&gt;state('won')
        unless grep(! $guessed{ $_ }, keys %letters);

    # do nothing more if no guess
    return $self-&gt;state('continue') unless $guess;

    # process individual letter guesses
    $guess = lc $guess;
    return $self-&gt;state(continue =&gt; 'Not a valid letter or word!') 
        unless $guess =~ /^[a-z]+$/;
    return $self-&gt;state(continue =&gt; 'You already guessed that letter!')
        if $guessed{$guess};

    # handle the user guessing the whole word
    if (length($guess) &gt; 1 and $guess ne $self-&gt;{word}) {
        $self-&gt;{ total } += $self-&gt;{ left };
        return $self-&gt;state(lost =&gt; "You lose.  The word was $self-&gt;{word}.");
    }

    # update the list of guesses and word map
    foreach ($guess =~ /(.)/g) { $guessed{$_}++; }
    $self-&gt;{ guessed } = join '', sort keys %guessed;

    # correct guess -- word completely filled in
    unless (grep(!$guessed{$_}, keys %letters)) {
        $self-&gt;{ won }++;
        return $self-&gt;state(won =&gt; qq{You got it!  The word was "$self-&gt;{word}".});
    }

    # incorrect guess
    if (!$letters{$guess}) {
        $self-&gt;{total}++;
        $self-&gt;{left}--;
        return $self-&gt;state(lost =&gt; 
            qq{No dice, dude! The word was "$self-&gt;{word}".})
                if $self-&gt;{left} &lt;= 0;
        return $self-&gt;state(continue =&gt; 'Wrong guess!');
    }

    # correct guess but word still incomplete
    return $self-&gt;state(continue =&gt; 'Good guess!');
}</pre></blockquote>

<p>As a matter of convenience, we also provide the <tt class="literal">state(
)</tt> method, to retrieve the current state (when called
without arguments) or set both state and message (when called with
one or more arguments):</p>

<blockquote><pre class="code">sub state {
    my $self = shift;
    if (@_) {
        $self-&gt;{ state   } = shift;
        $self-&gt;{ message } = join('', @_);
    }
    else {
        return $self-&gt;{ state };
    }
}</pre></blockquote>

<p>We also define <tt class="literal">averages( )</tt> and <tt class="literal">wordmap(
)</tt> as object methods:</p>

<blockquote><pre class="code">sub averages {
    my $self = shift;
    return {
        current =&gt; $self-&gt;{ total } / $self-&gt;{ gameno },
        overall =&gt; $self-&gt;{ gameno } &gt; 1 
             ? ($self-&gt;{ total } + $self-&gt;{ left } - $self-&gt;{ tries }) 
             / ($self-&gt;{ gameno } - 1)
             : 0
    };
}

sub wordmap {
    my $self = shift;
    my %guessed = map { $_ =&gt; 1 } $self-&gt;{ guessed } =~ /(.)/g;
    join ' ', map { $guessed{$_} ? "$_ " : '_ ' } 
        $self-&gt;{ word } =~ /(.)/g;
}</pre></blockquote>

<p>We can also encode the high-level game logic in a method:</p>

<blockquote><pre class="code">sub play {
    my $self = shift;

    # process any current guess
    $self-&gt;guess( );

    # determine which form to use based on state
    my $form = (exists $self-&gt;{ state } &amp;&amp;
                $self-&gt;{ state } =~ /^won|lost$/)
        ? 'restart' : 'guess';

    # process the three templates: header, form and footer
    $self-&gt;{ _context }-&gt;include([ 'header', $form, 'footer' ]);
}</pre></blockquote>

<p>The <tt class="literal">play( )</tt> method calls <tt class="literal">guess(
)</tt> to process a guess and then calls on the context object
that we previously saved in <tt class="literal">_context</tt> to process
three templates: the <em class="emphasis">header</em> template, the form
relevant to the current game state, and the
<em class="emphasis">footer</em> template.</p>

<p>The script that uses this plug-in can now be made even simpler, as
shown in <a href="appd_08.html#pmodperl-APP-D-EX-8">Example D-8</a>.</p>

<a name="pmodperl-APP-D-EX-8" /><div class="example">
<h4 class="objtitle">Example D-8. hangman3.pl</h4>
<blockquote><pre class="code">#!/usr/bin/perl
#
# hangman3.pl
#
# CGI script using Template Toolkit Hangman plug-in.
#

use strict;
use Template;

# may need to tell Perl where to find plug-in module
use lib qw( /usr/local/tt2/hangman/hangman3/perl5lib );

use constant TEMPLATES =&gt; '/home/stas/templates/hangman3';
use constant SHARED    =&gt; '/usr/local/tt2/templates';
use constant URL       =&gt; '/cgi-bin/hangman3.pl';
use constant ICONS     =&gt; '/icons/hangman';
use constant WORDS     =&gt; '/usr/games/hangman-words';

# create a Template object
my $tt = Template-&gt;new({
    INCLUDE_PATH =&gt; [ TEMPLATES, SHARED ],
});

# define Template variables
my $vars = {
    url   =&gt; URL,
    icons =&gt; ICONS,
    words =&gt; WORDS,
    title =&gt; 'Template Toolkit Hangman #3',
};

# process the main template
$tt-&gt;process(*DATA, $vars)
    || die $tt-&gt;error( );</pre></blockquote>
</div>

<p>Other than creating a <tt class="literal">Template</tt> object and defining
variables, we don't need to do any special
processing relevant to the hangman application. That is now handled
entirely by the plug-in.</p>

<p>The template defined in the <tt class="literal">_ _DATA_ _</tt>section can
be made to look very similar to the earlier example. In this case,
we're loading the plug-in
(<tt class="literal">Games.Hangman</tt>, corresponding to
<tt class="literal">Template::Plugin::Games::Hangman</tt>) and aliasing the
object returned from <tt class="literal">new( )</tt> to the
<tt class="literal">hangman</tt> variable. We manually call the
<tt class="literal">guess( )</tt> method and <tt class="literal">PROCESS</tt>
external templates according to the game state:</p>

<blockquote><pre class="code">_ _DATA_ _
Content-type: text/html

[%  WRAPPER html/page
        html.head.title  = title
        html.body.onload = 'if (document.gf) document.gf.guess.focus( )';

        TRY;
            # load the hangman plug-in
            USE hangman = Games.Hangman(
                words = words
                icons = icons
                url   = url
            );

            # process a guess
            CALL hangman.guess;

            # print header showing game averages
            PROCESS header;

            # process the right form according to game state
            IF hangman.state =  = 'won'
            OR hangman.state =  = 'lost';
                PROCESS restart;
            ELSE;
                PROCESS guess;
            END;

            # now print the footer
            PROCESS footer;
        CATCH;
            # and if any of that goes wrong...
            CLEAR;
            PROCESS error;
        END;
    END
%]</pre></blockquote>

<p>One other enhancement we've made is to enclose the
body in a <tt class="literal">TRY</tt> block. If the plug-in <tt class="literal">init(
)</tt> method fails to open the words file, it reports the error
via <tt class="literal">die( )</tt>. The <tt class="literal">TRY</tt> directive
allows this error to be caught and handled in the corresponding
<tt class="literal">CATCH</tt> block. This clears any output generated in
the <tt class="literal">TRY</tt> block before the error occured and
processes an <em class="emphasis">error</em> template instead to report
the error in a nice manner.</p>

<p>The template in this example controls the overall flow of the game
logic. If you prefer, you can simply call the <tt class="literal">play(
)</tt> method and have the plug-in take control. It handles all
the flow control for you, processing the guess and then making calls
back into the Template Toolkit to process the
<em class="emphasis">header</em>, relevant form, and
<em class="emphasis">footer</em> templates.</p>

<blockquote><pre class="code">_ _DATA_ _
Content-type: text/html

[%  #Template Toolkit Hangman #4
        WRAPPER html/page
        html.head.title  = title
        html.body.onload = 'if (document.gf) document.gf.guess.focus( )';

        TRY;
            USE hangman = Games.Hangman(
                words = words
                icons = icons
                url   = url
            );
            hangman.play;

        CATCH;
            CLEAR;
            PROCESS error;
        END;
    END
%]</pre></blockquote>

<p>The complete set of templates that go with this final example are
presented in Examples D-9 through D-15.</p>

<a name="pmodperl-APP-D-EX-9" /><div class="example">
<h4 class="objtitle">Example D-9. hangman3/templates/header</h4>
<blockquote><pre class="code">&lt;h1&gt;[% title %]&lt;/h1&gt;

[% # how many guesses left to go?
   tries_left = hangman.tries - hangman.left
%]

[%# display the appropriate image -%]  
&lt;img src="[% hangman.icons %]/h[% tries_left %].gif"
     align="left" alt="[[% tries_left %] tries left]" /&gt;

[% PROCESS status %]</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-10" /><div class="example">
<h4 class="objtitle">Example D-10. hangman3/templates/status</h4>
<blockquote><pre class="code">[% # define a format for displaying averages
   USE format('%2.3f');
   average = hangman.averages;
%]

&lt;table width="100%"&gt;
&lt;tr&gt;
  &lt;td&gt;&lt;b&gt;Word #: [% hangman.gameno %]&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;Guessed: [% hangman.guessed %]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
  &lt;td&gt;&lt;b&gt;Won: [% hangman.won %]&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;Current average: [% format(average.current) %]&lt;/b&gt;&lt;/td&gt;
  &lt;td&gt;&lt;b&gt;Overall average: [% format(average.overall) %]&lt;/b&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h2&gt;Word: [% hangman.wordmap %]&lt;/h2&gt;

[% IF hangman.message -%]
&lt;h2&gt;&lt;font color="red"&gt;[% hangman.message %]&lt;/font&gt;&lt;/h2&gt;
[% END %]</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-11" /><div class="example">
<h4 class="objtitle">Example D-11. hangman3/templates/guess</h4>
<blockquote><pre class="code">&lt;form method="post" action="[% hangman.url %]" 
      enctype="application/x-www-form-urlencoded" name="gf"&gt;
  Your guess: &lt;input type="text" name="guess" /&gt;
  &lt;input type="submit" name=".submit" value="Guess" /&gt;
  [% PROCESS state %]
&lt;/form&gt;</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-12" /><div class="example">
<h4 class="objtitle">Example D-12. hangman3/templates/restart</h4>
<blockquote><pre class="code">&lt;form method="post" action="[% hangman.url %]" 
      enctype="application/x-www-form-urlencoded"&gt;
  Do you want to play again?
  &lt;input type="submit" name="restart" value="Another game" /&gt;
  [% PROCESS state %]
&lt;/form&gt;</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-13" /><div class="example">
<h4 class="objtitle">Example D-13. hangman3/templates/state</h4>
<blockquote><pre class="code">[% FOREACH var = [ 'word' 'gameno' 'left' 'won' 'total' 'guessed' ] -%]
&lt;input type="hidden" name="[% var %]" value="[% hangman.$var %]" /&gt;
[% END %]</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-14" /><div class="example">
<h4 class="objtitle">Example D-14. hangman3/templates/footer</h4>
<blockquote><pre class="code">&lt;br clear="all"&gt;
&lt;hr /&gt;
&lt;a href="[% hangman.url %]"&gt;Home&lt;/a&gt;
&lt;p&gt;
  &lt;cite style="fontsize: 10pt"&gt;graphics courtesy Andy Wardley&lt;/cite&gt;
&lt;/p&gt;</pre></blockquote>
</div>

<a name="pmodperl-APP-D-EX-15" /><div class="example">
<h4 class="objtitle">Example D-15. hangman3/templates/error</h4>
<a name="pmodperl-APP-D-ITERM-6515" /><a name="pmodperl-APP-D-ITERM-6516" /><a name="pmodperl-APP-D-ITERM-6517" /><blockquote><pre class="code">&lt;h3&gt;Hangman Offline&lt;/h3&gt;
&lt;p&gt;
Hangman is unfortunately offline at present, reporting sick with 
the following lame excuse:
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;[[% error.type %]]&lt;/b&gt; [% error.info %]&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;</pre></blockquote>
</div>

</div>
<a name="pmodperl-APP-D-SECT-8.4" /><div class="sect2">
<h3 class="sect2">D.8.4. Self-Contained Hangman Template</h3>

<p>One of the benefits of <a name="pmodperl-APP-D-ITERM-6518" /><a name="pmodperl-APP-D-ITERM-6519" />writing the hangman application as a
plug-in is that you no longer need to write a CGI script at all. You
can load and use the plug-in from any template, which you can process
via a generic CGI script, a mod_perl handler, or perhaps the
<tt class="literal">Apache::Template</tt> module.</p>

<p>Here's an example of a self-contained template using
the hangman plug-in. All we need to do is to hardcode some variable
values at the start of the template:</p>

<blockquote><pre class="code">[%  title = 'Template Toolkit Hangman #5'
    url   = '/tt2/hangman.html'
    words = '/usr/games/hangman-words'
    icons = '/icons/hangman';

    WRAPPER html/page
        html.head.title  = title
        html.body.onload = 'if (document.gf) document.gf.guess.focus( )';

        TRY;
            USE hangman = Games.Hangman(
                words = words
                icons = icons
                url   = url
            );
            hangman.play;
        CATCH;
            CLEAR;
            PROCESS error;
        END;
    END
%]</pre></blockquote>

<p>If you're using <tt class="literal">Apache::Template</tt>
to run the application, you can define these variables in the Apache
<em class="emphasis">httpd.conf</em> file:</p>

<blockquote><pre class="code">PerlModule          Apache::Template

TT2IncludePath      /usr/local/tt2/hangman/hangman3/templates
TT2IncludePath      /usr/local/tt2/templates
TT2Variable         title  "Template Toolkit Hangman #5"
TT2Variable         words  /usr/games/hangman-words
TT2Variable         icons  /icons/hangman
TT2Params           uri

&lt;Location /tt2/hangman.html&gt;
    SetHandler      perl-script
    PerlHandler     Apache::Template
&lt;/Location&gt;</pre></blockquote>

<p>Our three variables, <tt class="literal">title</tt>,
<tt class="literal">words</tt>, and <tt class="literal">icons</tt>, are defined
using the <tt class="literal">TT2Variable</tt> directive. In addition, we
use <tt class="literal">TT2Params</tt> to instruct
<tt class="literal">Apache::Template</tt> to make the request URI available
as the <tt class="literal">uri</tt> template variable. We previously used
<tt class="literal">url</tt> to denote the URL of the hangman application,
so we need to make one small change to the template. Using this
dynamic <tt class="literal">uri</tt> variable should mean that the value
will remain correct even if the application is moved to a new URL.
The template should now look like this:</p>

<blockquote><pre class="code">[% 
    # ...etc...

    USE hangman = Games.Hangman(
        words   = words
        icons   = icons
        url     = uri     # now use 'uri' not 'url'
    );

    # ...etc...
%]</pre></blockquote>

<p>The game in <a href="appd_08.html#pmodperl-APP-D-FIG-3">Figure D-3</a> is for you to <a name="pmodperl-APP-D-ITERM-6520" /><a name="pmodperl-APP-D-ITERM-6521" />complete.</p>

<a name="pmodperl-APP-D-FIG-3" /><div class="figure"><img src="figs/pmp_ad03.gif" alt="Figure D-3" width="481" /></div><h4 class="objtitle">Figure D-3. White to play and mate in three moves</h4>

</div>


<hr width="684" align="left" />
<div class="navbar"><table width="684" border="0"><tr><td align="left" valign="top" width="228"><a href="appd_07.html"><img src="../images//txtpreva.gif" alt="Previous" border="0" /></a></td><td align="center" valign="top" width="228"><a href="index.html"><img src="../images//txthome.gif" alt="Home" border="0" /></a></td><td align="right" valign="top" width="228"><a href="appd_09.html"><img src="../images//txtnexta.gif" alt="Next" border="0" /></a></td></tr><tr><td align="left" valign="top" width="228">D.7. Apache::Template Module</td><td align="center" valign="top" width="228"><a href="index/index.html"><img src="../images//index.gif" alt="Book Index" border="0" /></a></td><td align="right" valign="top" width="228">D.9. References</td></tr></table></div>
<hr width="684" align="left" />


<p><p><font size="-1"><a href="copyrght.html">Copyright &copy; 2003</a> O'Reilly &amp; Associates. All rights reserved.</font></p>

<map name="library-map">
<area shape="rect" coords="0,0,85,92" href="../index.html"><area shape="rect" coords="89,1,204,113" href="../apache/index.html"><area shape="rect" coords="208,-1,296,136" href="../php/index.html"><area shape="rect" coords="301,-1,403,132" href="../modperl/index.html"><area shape="rect" coords="406,3,503,115" href="../mysql/index.html"><area shape="rect" coords="507,2,596,142" href="../lian/index.html"><area shape="rect" coords="600,1,690,127" href="../rlinux/index.html">
</map>

</body></html>